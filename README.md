  <b>BinaryHeap</b>
Напомним, что для компактного хранения в памяти компьютера полного бинарного дерева на n вершинах можно использовать одномерный массив длины n. Ключи вершин являются значениями элементов массива, индексация начинается с единицы, при этом у элемента с индексом i сыновьями являются элементы с индексами 2i и 2i + 1 (если такие элементы существуют).
Бинарная куча — полное бинарное дерево, для которого выполняется основное свойство структуры данных «куча»: элементы организованы таким образом, что приоритет любой вершины не ниже приоритета каждого из её сыновей.
Будем предполагать, что среди элементов тот элемент имеет наибольший приоритет, у которого ключевое значение меньше (Min-Heap).
Задан массив из n чисел. Необходимо проверить, может ли он представлять бинарную кучу.

  <b>BinomialHeap</b>
Биномиальное дерево высоты k обозначается через Bk и определяется следующим образом.
Биномиальное дерево B0 состоит из одной единственной вершины.
Биномиальное дерево Bk образуется присоединением биномиального дерева высоты k − 1 к корню другого биномиального дерева высоты k − 1 (во время присоединения корень одного из деревьев полагается одним из сыновей корня другого дерева).
Таким образом, биномиальное дерево Bk имеет корневую вершину, сыновьями которой являются корни биномиальных деревьев B0, B1, B2, …, Bk − 1.
Биномиальная куча состоит из набора биномиальных деревьев попарно различной высоты. Другими словами, для любого k ≥ 0 биномиальное дерево Bk либо не входит в состав кучи, либо входит ровно один раз.
Дано общее число n вершин в биномиальной куче. Определите, из каких биномиальных деревьев может состоять эта куча.


  <b> BlackBox </b>
Чёрный ящик организован наподобие примитивной базы данных. Он может хранить набор целых чисел и имеет выделенную переменную i. В начальный момент времени чёрный ящик пуст, а значение переменной i равно нулю. Чёрный ящик обрабатывает последовательность поступающих команд (запросов). Существуют два вида запросов:
Добавить(x) — положить в чёрный ящик элемент x;
Получить() — увеличить значение переменной i на 1 и выдать копию i-го по величине элемента чёрного ящика (напомним, что i-м по величине элементом называется число, стоящее на i-м месте в отсортированной по неубыванию последовательности элементов чёрного ящика).
Необходимо разработать алгоритм, обрабатывающий заданную последовательность поступающих команд (запросов) за время O(m ⋅ logm), где m — число запросов Добавить.

<b> HashTable </b> 
Хеш-таблица состоит из m ячеек (ячейки нумеруются целыми числами от 0 до m − 1). Для разрешения коллизий используется метод открытой адресации. Функция
h(x, i) = ((x mod m) + c ⋅ i) mod m
задает линейную последовательность проб свободных ячеек, где x — ключ, i — номер попытки (попытки нумеруются с нуля), c — константа.
В таблицу было последовательно добавлено n ключей. В случае, если ключ в таблице уже есть, повторного добавления не происходит.
Определите, какой ключ хранится в каждой ячейке таблицы по окончании выполнения всех операций.

  <b> Huffman </b>
Кодирование Хаффмана (D. A. Huffman) относится к префиксному кодированию, позволяющему минимизировать длину текста за счёт того, что различные символы кодируются различным числом битов.Напомним процесс построения кода.
Вначале строится дерево кода Хаффмана. Пусть исходный алфавит состоит из n символов, i-й из которых встречается p_i раз во входном тексте. Изначально все символы считаются активными вершинами будущего дерева, i-я вершина помечена значением p_i. На каждом шаге мы берём две активных вершины с наименьшими метками, создаём новую вершину, помечая её суммой меток этих вершин, и делаем её их родителем. Новая вершина становится активной, а двое её сыновей из списка активных вершин удаляются. Процесс многократно повторяется, пока не останется только одна активная вершина, которая полагается корнем дерева.Заметим, что символы алфавита представлены листьями этого дерева. Для каждого листа (символа) длина его кода Хаффмана равна длине пути от корня дерева до него.
Сам код строится следующим образом: для каждой внутренней вершины дерева рассмотрим две дуги, идущие от неё к сыновьям. Одной из дуг присвоим метку 0, другой — 1. Код каждого символа — последовательность из нулей и единиц на пути от корня к листу.Задача состоит в том, чтобы вычислить длину текста после его кодирования методом Хаффмана. Сам текст не дан, известно лишь, сколько раз каждый символ встречается в тексте. Этого достаточно для решения задачи, поскольку длина кода зависит только от частоты появления символов. Разработайте алгоритм, работающий за n, где n - количество частот появления символов.

  <b> RoadConstruction </b>
Берляндия состоит из n городов. Изначально все города изолированы, то есть между городами нету дорог. По очереди будут добавляться дороги между парами городов. Необходимо после каждой добавленной дороги узнать, какое количество компонент связности из городов получилось.

  <b> RoadDestruction </b>
В Берляндии n городов, связанных m дорогами. Гарантируется, что изначально граф из городов связный, т.е. существует путь между любой парой вершин.В Берляндии происходит q землетрясений, в ходе каждого из них разрушается ровно одна дорога. Необходимо после каждого землетрясения узнать, является ли полученный граф из городов связным. После очередного землетрясений дорога не перестраивается, то есть разрушается навсегда.

  <b> SuffixArray </b>
Дана строка S, длина которой равна n. Необходимо вычислить суффиксный массив данной строки. Суффиксный массив — такая перестановка первых n натуральных чисел, что если число x встречается в этой перестановке раньше числа y, то суффикс, который начинается в позиции x лексикографически меньше суффикса, который начинается в позиции y.

  <b> SumProblem </b>
Рассмотрим следующую модельную задачу. Изначально дана последовательность чисел A длины n (индексация с нуля):
a_0, a_1, a_2, ... a_(n-1).
Поступают запросы двух типов.
Запрос модификации. Задан индекс i и число x. Нужно прибавить к i-му элементу число x.
Запрос суммы. Задана пара индексов l и r. Нужно вычислить сумму элементов на полуинтервале [l, r), т. е. a_l + a_(l+1) + ... + a_(r - 1), и вернуть результат.
